<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ASR JS</title>
    <style>
        :root {
            --primary-color: #007AFF;
            --secondary-color: #5AC8FA;
            --accent-color: #FF9500;
            --success-color: #34C759;
            --danger-color: #FF3B30;
            --warning-color: #FFCC00;
            --purple-color: #AF52DE;
            --teal-color: #64D2FF;
            --background-color: #F2F2F7;
            --card-background: #FFFFFF;
            --text-color: #000000;
            --text-secondary: #8E8E93;
            --border-radius: 12px;
            --button-radius: 10px;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #F2F2F7 0%, #E5E5EA 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            color: var(--text-color);
            -webkit-font-smoothing: antialiased;
        }
        
        .container {
            background-color: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 2.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.05);
            border-radius: var(--border-radius);
            text-align: center;
            width: 85%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        
        h1 {
            margin-bottom: 1.5rem;
            font-weight: 700;
            font-size: 2rem;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, var(--primary-color), var(--purple-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .chat-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            height: 350px;
            overflow-y: auto;
            border: 1px solid rgba(0, 0, 0, 0.08);
            padding: 1rem;
            border-radius: var(--border-radius);
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            width: 100%;
            margin-bottom: 1.5rem;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.03);
        }
        
        .input-container {
            display: flex;
            width: 100%;
        }
        
        #textInput {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--button-radius);
            font-size: 1rem;
            margin-right: 0.5rem;
            font-family: inherit;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.03);
            transition: all 0.2s ease;
        }
        
        #textInput:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2);
        }
        
        #sendButton {
            background-color: var(--primary-color);
            color: #fff;
            border: none;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border-radius: var(--button-radius);
            cursor: pointer;
            font-weight: 500;
            box-shadow: 0 2px 5px rgba(0, 122, 255, 0.3);
        }
        
        #sendButton:hover {
            background-color: #0062CC;
            transform: translateY(-1px);
        }
        
        .message {
            padding: 0.75rem 1.25rem;
            border-radius: 18px;
            margin-bottom: 0.75rem;
            max-width: 70%;
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            animation: fadeIn 0.3s ease;
            transition: all 0.2s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-message {
            align-self: flex-end;
            background: linear-gradient(135deg, var(--primary-color), #0062CC);
            color: #fff;
            box-shadow: 0 2px 5px rgba(0, 122, 255, 0.3);
        }
        
        .response-message {
            align-self: flex-start;
            background-color: #E5E5EA;
            color: #000;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        #audioPlayer {
            display: none;
        }
        
        .buttons {
            margin-top: 1.5rem;
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            justify-content: center;
        }
        
        .control-group {
            margin-top: 1.5rem;
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            justify-content: center;
            background: linear-gradient(135deg, rgba(242, 242, 247, 0.8), rgba(229, 229, 234, 0.8));
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding: 1.25rem;
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        .control-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            min-width: 200px;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        
        .control-item label {
            margin-bottom: 0.75rem;
            color: var(--text-color);
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(to right, var(--primary-color), var(--teal-color));
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #FFFFFF;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
        }
        
        .processing-message {
            font-style: italic;
            color: var(--text-secondary);
            border-left: 3px solid var(--primary-color);
            padding-left: 10px;
            background: linear-gradient(to right, rgba(90, 200, 250, 0.1), rgba(242, 242, 247, 0.8));
        }
        
        .completed-message {
            color: #000;
            font-weight: normal;
            transition: all 0.3s ease;
        }
        
        #apikeyInput {
            padding: 0.75rem 1rem;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--button-radius);
            font-size: 0.95rem;
            font-family: inherit;
            width: 220px;
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.03);
            transition: all 0.2s ease;
        }
        
        #apikeyInput:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.95);
        }
        
        #apikeyInput::placeholder {
            color: var(--text-secondary);
            font-weight: 300;
        }
        
        #startButton, #stopButton {
            border: none;
            padding: 0.85rem 1.5rem;
            font-size: 1rem;
            border-radius: var(--button-radius);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            color: white;
            min-width: 130px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #startButton {
            background: linear-gradient(135deg, var(--success-color), #27AD4A);
            box-shadow: 0 4px 10px rgba(52, 199, 89, 0.3);
        }
        
        #stopButton {
            background: linear-gradient(135deg, var(--danger-color), #E0352A);
            box-shadow: 0 4px 10px rgba(255, 59, 48, 0.3);
        }
        
        #startButton:hover {
            background: linear-gradient(135deg, #30BD54, #259540);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(52, 199, 89, 0.4);
        }
        
        #stopButton:hover {
            background: linear-gradient(135deg, #FF352B, #D02F24);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(255, 59, 48, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        /* 添加按钮图标 */
        #startButton::before {
            content: "▶";
            margin-right: 8px;
            font-size: 0.8rem;
        }
        
        #stopButton::before {
            content: "■";
            margin-right: 8px;
            font-size: 0.8rem;
        }
        
        /* 添加标题装饰 */
        .app-header {
            position: relative;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 2rem;
        }
        
        .app-header::before, .app-header::after {
            content: "";
            height: 2px;
            background: linear-gradient(to right, transparent, var(--secondary-color), transparent);
            flex: 1;
            margin: 0 15px;
        }
        
        /* 增强悬停效果 */
        .message:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
        }
        
        /* 进度指示器 */
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        .processing-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--primary-color);
            margin-left: 5px;
            animation: pulse 1.5s infinite ease-in-out;
        }
        
        .processing-message::after {
            content: "";
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--primary-color);
            margin-left: 5px;
            animation: pulse 1.5s infinite ease-in-out;
        }
        
        /* 设置值指示器美化 */
        #sensitivityValue, #pauseTimeValue {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
            color: var(--primary-color);
            display: inline-block;
            min-width: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin-left: 5px;
        }
        
        /* 滚动条美化 */
        .chat-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .chat-container::-webkit-scrollbar-track {
            background: rgba(242, 242, 247, 0.5);
            border-radius: 4px;
        }
        
        .chat-container::-webkit-scrollbar-thumb {
            background: rgba(142, 142, 147, 0.4);
            border-radius: 4px;
        }
        
        .chat-container::-webkit-scrollbar-thumb:hover {
            background: rgba(142, 142, 147, 0.6);
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <div class="app-header">
            <h1>语音识别助手</h1>
        </div>
        <div id="chat" class="chat-container"></div>
        <div class="control-group">
            <div class="control-item">
                <label for="sensitivityRange">灵敏度<span id="sensitivityValue">5</span></label>
                <input type="range" id="sensitivityRange" min="1" max="10" value="5">
            </div>
            <div class="control-item">
                <label for="pauseTimeRange">停顿时间<span id="pauseTimeValue">800</span>ms</label>
                <input type="range" id="pauseTimeRange" min="300" max="2000" step="100" value="800">
            </div>
        </div>
        <div class="buttons">
            <input type="text" id="apikeyInput" placeholder="输入您的API Key">
            <button id="startButton">开始录音</button>
            <button id="stopButton" disabled>停止录音</button>
        </div>
    </div>
    <script type='module'>
        import PCMAudioRecorder from './audio_recorder.js';
        import ParaformerRealtime from './paraformer_realtime_api.js'

        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const textInput = document.getElementById('apikeyInput');
        const chat = document.getElementById('chat');
        const sensitivityRange = document.getElementById('sensitivityRange');
        const sensitivityValue = document.getElementById('sensitivityValue');
        const pauseTimeRange = document.getElementById('pauseTimeRange');
        const pauseTimeValue = document.getElementById('pauseTimeValue');
        
        let processingMessage = null;  // 当前正在处理的消息
        let completedSentences = [];   // 已完成的句子列表
        let lastReceivedText = '';     // 上次收到的完整文本
        let pauseDetectionTimer = null;
        
        // 更新UI中的值显示
        sensitivityRange.addEventListener('input', () => {
            sensitivityValue.textContent = sensitivityRange.value;
        });
        
        pauseTimeRange.addEventListener('input', () => {
            pauseTimeValue.textContent = pauseTimeRange.value;
        });
        
        // 增强型文本处理器
        const textProcessor = {
            sensitivity: 5,            // 灵敏度设置
            lastCompleteSentence: '',  // 上一个完整句子
            knownSentences: new Set(), // 用于追踪已知句子，避免重复
            
            setSensitivity: function(value) {
                this.sensitivity = value;
                console.log('灵敏度设置为:', value);
            },
            
            // 判断新文本是否为已知句子的扩展
            isTextExtension: function(previousText, newText) {
                if (!previousText) return false;
                // 确保新文本包含旧文本作为前缀
                return newText.startsWith(previousText);
            },
            
            // 判断是否是全新的句子（基于灵敏度）
            isNewSentence: function(newText) {
                // 检查是否和任何已知句子有太大重合
                for (let sentence of this.knownSentences) {
                    // 如果句子基本相同，就不是全新的
                    if (this.textSimilarity(sentence, newText) > (10 - this.sensitivity) / 10) {
                        return false;
                    }
                }
                return true;
            },
            
            // 计算两个文本的相似度 (0-1)
            textSimilarity: function(text1, text2) {
                if (!text1 || !text2) return 0;
                
                // 简单实现：共同字符数 / 较长字符串长度
                const shorter = text1.length <= text2.length ? text1 : text2;
                const longer = text1.length > text2.length ? text1 : text2;
                
                let commonChars = 0;
                for (let i = 0; i < shorter.length; i++) {
                    if (longer.includes(shorter[i])) commonChars++;
                }
                
                return commonChars / longer.length;
            },
            
            // 处理新收到的语音识别结果
            processRecognitionResult: function(text) {
                if (!text || text.trim() === '') return null;
                
                // 完全相同的文本直接忽略
                if (text === this.lastCompleteSentence) {
                    return null;
                }
                
                // 文本变化非常小时忽略（基于灵敏度）
                if (this.lastCompleteSentence && 
                    this.textSimilarity(text, this.lastCompleteSentence) > 0.9) {
                    return null;
                }
                
                // 检查是否是当前句子的扩展
                if (this.isTextExtension(this.lastCompleteSentence, text)) {
                    // 这是一个增量更新，返回完整文本
                    this.lastCompleteSentence = text;
                    return {
                        text: text,
                        isExtension: true
                    };
                } else if (this.isNewSentence(text)) {
                    // 这是一个全新的句子
                    this.knownSentences.add(this.lastCompleteSentence);
                    this.lastCompleteSentence = text;
                    return {
                        text: text,
                        isExtension: false,
                        isNew: true
                    };
                } else {
                    // 这个句子与已知句子有部分重叠但不是扩展
                    // 基于灵敏度决定是否接受
                    if (Math.random() < this.sensitivity / 10) {
                        this.lastCompleteSentence = text;
                        return {
                            text: text,
                            isExtension: false
                        };
                    }
                    return null;
                }
            },
            
            // 重置处理器状态
            reset: function() {
                this.lastCompleteSentence = '';
                this.knownSentences.clear();
                console.log('文本处理器已重置');
            },
            
            // 新增配置项
            maxLineLength: 30,  // 一行最大字符数，超过将换行
        };

        let recorder = new PCMAudioRecorder();
        let paraformer = null;

        // 更新正在处理的消息
        function updateProcessingMessage(result) {
            // 如果没有处理结果，直接返回
            if (!result) return;
            
            const text = result.text;
            
            // 如果是新句子，或者当前没有处理中的消息
            if (result.isNew || !processingMessage) {
                // 如果已有处理中的消息，先完成它
                if (processingMessage) {
                    finalizeCurrentSentence();
                }
                
                // 创建新的处理消息
                processingMessage = document.createElement('div');
                processingMessage.className = 'message response-message processing-message';
                processingMessage.textContent = text;
                chat.appendChild(processingMessage);
            } else {
                // 是当前句子的扩展，检查长度是否超过限制
                if (text.length > textProcessor.maxLineLength) {
                    // 如果超过设定长度，完成当前句子并创建新句子
                    finalizeCurrentSentence();
                    processingMessage = document.createElement('div');
                    processingMessage.className = 'message response-message processing-message';
                    processingMessage.textContent = text;
                    chat.appendChild(processingMessage);
                } else {
                    // 在同一个消息元素中更新文本
                    processingMessage.textContent = text;
                }
            }
            
            chat.scrollTop = chat.scrollHeight;
            
            // 重置停顿检测
            resetPauseDetectionTimer();
        }
        
        // 改进: 添加一个段落管理功能
        function manageParagraphs() {
            // 获取所有已完成的消息
            const completedMessages = Array.from(chat.querySelectorAll('.completed-message'));
            
            // 如果已有足够多的消息，尝试合并它们
            if (completedMessages.length >= 3) {
                // 保持最近的几个句子分开显示
                const messagesToMerge = completedMessages.slice(0, -2);
                
                if (messagesToMerge.length >= 2) {
                    // 创建一个合并后的段落
                    const mergedParagraph = document.createElement('div');
                    mergedParagraph.className = 'message response-message completed-message';
                    
                    // 合并文本内容
                    const mergedText = messagesToMerge.map(msg => msg.textContent).join(' ');
                    mergedParagraph.textContent = mergedText;
                    
                    // 替换原来的消息元素
                    chat.insertBefore(mergedParagraph, messagesToMerge[0]);
                    messagesToMerge.forEach(msg => chat.removeChild(msg));
                }
            }
        }
        
        // 完成当前正在处理的句子
        function finalizeCurrentSentence() {
            if (processingMessage && processingMessage.textContent.trim()) {
                // 把处理中的消息标记为已完成
                processingMessage.classList.remove('processing-message');
                processingMessage.classList.add('completed-message');
                
                // 记录已完成的句子，用于去重
                completedSentences.push(processingMessage.textContent);
                
                // 保持列表在合理大小
                if (completedSentences.length > 20) {
                    completedSentences = completedSentences.slice(-20);
                }
                
                // 创建新的处理消息元素
                processingMessage = null;
                
                // 管理段落合并
                manageParagraphs();
            }
        }
        
        // 重置停顿检测定时器
        function resetPauseDetectionTimer() {
            if (pauseDetectionTimer) {
                clearTimeout(pauseDetectionTimer);
            }
            
            const pauseTime = parseInt(pauseTimeRange.value);
            pauseDetectionTimer = setTimeout(() => {
                if (processingMessage && processingMessage.textContent.trim()) {
                    finalizeCurrentSentence();
                }
            }, pauseTime);
        }

        // 添加消息到聊天框
        function addMessage(text, className) {
            const message = document.createElement('div');
            message.className = `message ${className}`;
            message.textContent = text;
            chat.appendChild(message);
            chat.scrollTop = chat.scrollHeight;
            return message;
        }

        startButton.onclick = async () => {
            try {
                // 更新文本处理器的行长度设置
                const sensitivity = parseInt(sensitivityRange.value);
                // 灵敏度越高，每行字数越少，更容易换行
                textProcessor.maxLineLength = Math.max(15, 35 - sensitivity * 2);
                console.log(`设置每行最大字数：${textProcessor.maxLineLength}`);
                
                // 重置状态
                textProcessor.reset();
                chat.innerHTML = '';
                processingMessage = null;
                completedSentences = [];
                lastReceivedText = '';
                
                // 设置灵敏度
                textProcessor.setSensitivity(parseInt(sensitivityRange.value));
                
                let apikey = textInput.value.trim();
                if (!apikey) {
                    alert('请输入apikey');
                    return;
                }
                
                paraformer = new ParaformerRealtime('wss://dashscope.aliyuncs.com/api-ws/v1/inference/?api_key='+apikey);

                await paraformer.connect((payload) => {
                    let text = payload.output.sentence.text;
                    if (text && text.trim()) {
                        // 使用文本处理器处理新文本
                        const processedResult = textProcessor.processRecognitionResult(text);
                        
                        if (processedResult) {
                            // 更新显示，始终显示完整句子
                            updateProcessingMessage(processedResult);
                            lastReceivedText = text;
                        }
                    }
                });
                
                console.log('paraformer connected');
                await recorder.connect(async (pcmData) => {
                    paraformer.sendAudio(pcmData);
                });

                startButton.disabled = true;
                stopButton.disabled = false;

            } catch (error) {
                console.error('Error:', error);
            }
        };

        stopButton.onclick = async () => {
            console.log('stop button is clicked');
            recorder.stop();
            await paraformer.stop();
            
            // 结束当前句子
            finalizeCurrentSentence();
            
            console.log('paraformer stopped');
            startButton.disabled = false;
            stopButton.disabled = true;
        };
    </script>
</body>
</html>
